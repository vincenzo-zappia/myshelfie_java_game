1. Test possono essere tra classi o solo specifici a classe?

Sì ma in secondo luogo. Ad esempio in GameController verrà testata la corretta interazione tra le funzionalità delle entità in Game.

2. Se ho bisogno di metodi specifici all'interno dei test questi possono/devono essere dichiarati all'interno della classe test (metodi non @Test)?

Sì, si possono creare interi programmi per la facilitazione e la corretta implementazione di test.

3. "gruppi di blocchi separati" nei common goal?

Scegliamo noi se attaccate o meno (ma non sovrapposte)!

4. getter e setter (anche particolari) vanno sull'UML?

Non essenziale.


Ci mancano:
1. Controllo dei turni (da parte di GameController) e conseguente gestione fine gioco
2. Formattazione comandi XML (poi verificati da GameController)
3. Formattazione private goal XML
4. Implementazione conteggio punteggi
5. Test vari

TODO:
1. Analizzare il coverage: per classi complesse si vuole raggiungere idealmente il 90%.

2. Il Controller del Client serializza il comando che viene dalla View (interazione GUI). Il comando viene deserializzato in Server dal Controller (diverso o uguale al nostro GameController) (il ruolo di Controller in Server è principalmente quello di deserializzare il comando ricevuto, l'applicazione del comando può essere gestita da un'altra classe).

3. Observer/Observable: in Server la Virtual View osserva Model. Tutte le volte che Model è modificato la modifica viene notificata alla View. La notifica contiene l'oggetto modificato.

4. L'oggetto modificato viene inoltrato via rete al Client e modifica lo stato corrente del Virual Model (Virtual Model è un'istanza di gioco locale che contiene quasi tutto il Model di Server: contiene solo le parti che servono alla View per la generazione dei comandi. Ad esempio serve quando il client seleziona le carte da voler piazzare e ottiene feedback sulla validità della selezione subito invece di aspettare di ricevere l'errore una volta inviato il comando finale). 

