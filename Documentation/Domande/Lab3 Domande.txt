1. VirtualView è la classe che si occupa di inviare update al Client ogni volta che avviene un cambiamento. Per pulizia il metodo update() dovrebbe avere come parametro il messaggio già serializzato. I cambiamenti nel modello avvengono a tutti gli effetti attraverso la classe GameController. Deve essere GameController la classe che, oltre ad implementare Subject, deve serializzare il messaggio o esiste un modo per separare i compiti?

(Guarda TODO).

2. Chi deve estendere la classe Subject? Ogni entità di gioco oppure solo Game? Ovvero chi sono le classi responsabili di generare messaggi Server -> Client?

Singole entità o Game, decidiamo noi.

server -> client manda direttamente se stesso alla view notify(se stesso) ed è la virtual view che genera messaggio

3. Necessaria ulteriore classe tra GameController e Lobby?

Sufficiente Lobby.

4. Rendere invio e ricevimento comandi asincrono rispetto all'effettiva esecuzione dei comandi già validati. (Cosa succede se un Client di cui non è il turno prova ad inviare un comando al Server che sta cambiando modello in base a comando lecito?)

(Guarda TODO).

5. Legalità mossa 1 a 1?

x


TODO:
0. Più importante è ciò che serve, non pensare prima alla forma! (Meglio andare a cazz* di cane).

1. Interfaccia Message che viene implementata da tutti i tipi di messaggi che possono scambiarsi Client e Server: oggetti che devono poter essere serializzati e deserializzati. Ogni Message dovrebbe essere serializzato in testo o binario e poi ricostruito (non scambio testuale).

2. Classe Controller che gestisce i Message. Ha metodi overloaded handle(Message message) synchronized che ricostruisce l'oggetto. Appena ricevuto un Message è generico, serve metodo handleMessage() che, implementando design pattern Visitor chiama l'implementazione specifica di handle():

public interface Message{
	public void visit();
}

public class PlayerMessage{
	public void visit(Controller c){
		c.handle(this);
	}
}


public class Controller{
	public void synchronized handle(PlayerMessage m){
		...
	}

	public void synchronized handle(GameMessage m){
		...
	}

	public void synchronized handleMessage(Message m){
		m.visit(this);
	}
}

Gli handle() sono synchronized così che la gestione dei comandi sia asincrona rispetto ai turni di gioco: turnAction() continua a chiamate di handle() che sputano solo i comandi già filtrati (in termini di correttezza di turno e non ti legalità di gioco).

Una volta ricostruito l'oggetto:

message m = readMessage()
controller.handle(m)

3. Gerarchia di messaggi che implementano stessa interfaccia. Qualcuno che riguarda fase di creazione partita altri specifici di gioco.

4. Jackson libreria per serializzare e deserializzare oppure a mano. (Serializzazione e deserializzazione sono compito della rete).

